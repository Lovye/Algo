<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>动态规划</title>
    <link rel="icon" href="https://icpc.global/favicon.ico">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/general.css">
</head>
<body>
    <div id="nav">
        <button id="index" data-url="index.html">算法</button>
        <button id="search" data-url="search.html">搜索</button>
        <button id="greedy" data-url="greedy.html">贪心</button>
        <button id="math" data-url="math.html">数论</button>
        <button id="dp" data-url="dp.html">动态规划</button>
        <button id="graph" data-url="graph.html">图论</button>
    </div>
    <div id="content">
        <div id="left">
            <button id="welcome" data-url="index.html">欢迎</button>
            <button id="about" data-url="index/about.html">关于ACM</button>
            <button id="time-complexity" data-url="index/time-complexity.html">算法复杂度</button>
            <button id="board-xcpc" data-url="https://board.xcpcio.com/">Board-XCPC</button>
            <button id="icpc" data-url="https://icpc.global/">ICPC</button>
        </div>
        <div id="context">
            <h3 class="text-shadow-red">什么是动态规划</h3>
            <div class="text border">
                <p>动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。
                    20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，
                    提出了著名的最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、
                    工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、
                    最短路径问题和复杂系统可靠性问题等中取得了显著的效果。</p>
            </div>
            <br />
            <h3 class="text-shadow-red">基本思想</h3>
            <div class="text text-border">
                <p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，
                    我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，
                    然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。
                    若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，
                    而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。
                    不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，
                    但它们具有相同的填表格式。</p>
            </div>
            <br />
            <h3 class="text-shadow-red">基本概念</h3>
            <li class="blue">多阶段决策问题</li>
            <div class="text text-border">
                <p>如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策（采取措施），一个阶段的决策确定以后，常常影响到下一个阶段的决策，
                    从而就完全确定了一个过程的活动路线，则称它为多阶段决策问题。</p>
                <p>各个阶段的决策构成一个决策序列，称为一个策略。每一个阶段都有若干个决策可供选择，因而就有许多策略供我们选取，对应于一个策略可以确定活动的效果，
                    这个效果可以用数量来确定。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果。</p>
            </div>
            <li class="blue">动态规划问题中的术语</li>
            <div class="text text-border">
                <p><span class="red">阶段：</span>把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同．描述阶段的变量称为阶段变量。
                    在多数情况下，阶段变量是离散的，用k表示。此外，也有阶段变量是连续的情形。如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续的。</p>
                <p><span class="red">状态：</span>状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。在上面的例子中状态就是某阶段的出发位置，它既是该阶段某路的起点，
                    同时又是前一阶段某支路的终点。</p>
                <p><span class="red">无后效性：</span>我们要求状态具有下面的性质：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响，所有各阶段都确定时，整个过程也就确定了。换句话说，
                    过程的每一次实现可以用一个状态序列表示，在前面的例子中每阶段的状态是该线路的始点，确定了这些点的序列，整个线路也就完全确定。从某一阶段以后的线路开始，当这段的始点给定时，不受以前线路（所通过的点）的影响。
                    状态的这个性质意味着过程的历史只能通过当前的状态去影响它的未来的发展，这个性质称为无后效性。</p>
                <p><span class="red">决策：</span>一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为决策。在最优控制中，也称为控制。在许多问题中，决策可以自然而然地表示为一个数或一组数。
                    不同的决策对应着不同的数值。描述决策的变量称决策变量，因状态满足无后效性，故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史。</p>
                <p><span class="red">策略：</span>由每个阶段的决策组成的序列称为策略。对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为允许策略集合。</p>
            </div>
            <br />
            <h3 class="text-shadow-red">适用条件</h3>
            <div class="text text-border">
                <p>任何思想方法都有一定的局限性，超出了特定条件，它就失去了作用。同样，动态规划也并不是万能的。适用动态规划的问题必须满足最优化原理和无后效性。</p>
                <p><span class="red">最优化原理：</span>最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。
                    一个问题满足最优化原理又称其具有最优子结构性质。 </p>
                <p><span class="red">无后效性：</span>将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。</p>
                <p><span class="red">子问题的重叠性：</span>动态规划算法的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其他的算法。
                    选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们舍空间而取时间。</p>
            </div>
            <br />
            <h3 class="text-shadow-red">斐波那契数列</h3>
            <div class="text text-border">
                <p>斐波那契数列可以说是最简单的dp，也是所有动态规划的始祖。状态转移方程也是其本身的定义：f[i] = f[i - 1] + f[i - 2]。</p>
                <p>与之类似的有兔子繁衍问题，爬梯子问题等。其状态转移方程都是 f[i] = f[i - 1] + f[i - 2]。</p>
                <p>下面简单的对爬梯子问题进行解释：</p>
                <p>当人在第i阶梯子的时候，我们知道可以从第i - 1阶梯子到第i阶梯子，也可以从第i - 2阶梯子到第i阶梯子。
                    所以我们得到了状态i可以由状态i - 1和状态i - 2转移得到，把两者相加就是到第i阶梯子的方案数。
                </p>
            </div>
            <br />
            <h3 class="text-shadow-red">01背包</h3>
            <div class="text text-border">
                <p>01背包的问题描述为：</p>
                <p>有N件物品和一个容量为V的背包。第i件物品的体积是c[i]，价值是w[i]。求解将物品装入背包价值总和最大是多少。</p>
                <p>我们用 f[i + 1][j] 表示从0到i + 1个物品中选出总重量不超过j的物品时总价值的最大值。</p>
                <p>我们可以得到状态转移方程 f[ i + 1 ][ j ] = f[ i ][ j ]（选第i个物品后超出了背包大小）</p>
                <p>以及 f[ i + 1 ][ j ] = max( f[ i ][ j ], f[ i ][ j - w[ i ] ] + v[ i ] ) （选第i个物品和不选第i个中取最大）</p>
            </div>
        </div>
        <div class="space"></div>
    </div>
    <footer>
        <p>powered by Deng</p>
    </footer>
    <script src="js/index.js"></script>
</body>
</html>